use super::*;
use std::collections::HashMap;
use std::future::ready;
use std::str::FromStr;

const FLINDERS: Stop = Stop {
    route_type: RouteType::TRAIN,
    id: StopId::new(1071),
};

/// Build a PTV instance which is testable
struct MockClient(HashMap<String, Result<String>>);
impl PTVHttpClient for MockClient {
    fn api_get<T: DeserializeOwned + Send + 'static>(&self, url: Url) -> FutureResult<T> {
        let result = self
            .0
            .get(url.as_str())
            .or_else(|| self.0.get("*"))
            .expect(&format!("Failed to get URL {url}"));
        let result = match result {
            Ok(json) => serde_json::from_str(&json).map_err(Error::from),
            Err(err) => Err(err.clone()),
        };
        Box::pin(ready(result))
    }
}
impl PTV<MockClient> {
    fn mock(mapping: HashMap<String, Result<String>>) -> PTV<MockClient> {
        PTV {
            http_client: MockClient(mapping),
            devid: "0".to_string(),
            key: "00000000-0000-0000-0000-000000000000".to_string(),
            base: Url::parse(BASE_URL).unwrap(),
        }
    }
}

/// Test that we can build and sign departure URLs correctly
/// Target URLs generated by the official Swagger test UI
#[tokio::test]
async fn test_departures_params() {
    let ptv = PTV::mock(Default::default());

    // No parameters
    assert_eq!(
        ptv.build_url("v3/departures/route_type/0/stop/1071", ()).to_string(),
        "https://timetableapi.ptv.vic.gov.au/v3/departures/route_type/0/stop/1071?devid=0&signature=42DB35865957B23483EB372990105E9BC57F90CD"
    );

    // Should match the above
    let params = DeparturesParams {
        ..Default::default()
    };
    assert_eq!(
        ptv.build_url("v3/departures/route_type/0/stop/1071", params).to_string(),
        "https://timetableapi.ptv.vic.gov.au/v3/departures/route_type/0/stop/1071?devid=0&signature=42DB35865957B23483EB372990105E9BC57F90CD"
    );

    let params = DeparturesParams {
        include_cancelled: Some(true),
        ..Default::default()
    };
    assert_eq!(
        ptv.build_url("v3/departures/route_type/0/stop/1071", params).to_string(),
        "https://timetableapi.ptv.vic.gov.au/v3/departures/route_type/0/stop/1071?include_cancelled=true&devid=0&signature=E806A7A79C6C5012B409DA3BE153D2A640F449CD"
    );

    // TODO: use a proper time type instead of a string
    let params = DeparturesParams {
        date_utc: Some("1970-01-01T00:00:00Z".to_string()),
        ..Default::default()
    };
    assert_eq!(
        ptv.build_url("v3/departures/route_type/0/stop/1071", params).to_string(),
        "https://timetableapi.ptv.vic.gov.au/v3/departures/route_type/0/stop/1071?date_utc=1970-01-01T00%3A00%3A00Z&devid=0&signature=B6A285B7184C0AA63D5BDA533314B6506523AAD2"
    );

    let params = DeparturesParams {
        expand: Some(vec![ResponseExpand::Route]),
        ..Default::default()
    };
    assert_eq!(
        ptv.build_url("v3/departures/route_type/0/stop/1071", params).to_string(),
        "https://timetableapi.ptv.vic.gov.au/v3/departures/route_type/0/stop/1071?expand=Route&devid=0&signature=59F8316A7E7B06E44712B4D6CF59B8587F7D9218"
    );

    let params = DeparturesParams {
        expand: Some(vec![ResponseExpand::Route, ResponseExpand::Run]),
        ..Default::default()
    };
    assert_eq!(
        ptv.build_url("v3/departures/route_type/0/stop/1071", params).to_string(),
        "https://timetableapi.ptv.vic.gov.au/v3/departures/route_type/0/stop/1071?expand=Route&expand=Run&devid=0&signature=88DCDBA082D1B9AD22B9D0722D8C6486186CF7D0"
    );
}

/// Smoke test for parsing real train data
#[tokio::test]
async fn test_train() {
    let data = std::fs::read_to_string("testdata/departures_0_1181.json").unwrap();
    let ptv = PTV::mock(HashMap::from([("*".to_string(), Ok(data))]));
    let result = ptv
        .departures(&FLINDERS, Default::default())
        .await
        .expect("Parsing failed");
    eprintln!("{:#?}", result);
}

/// Smoke test for parsing real tram data
#[tokio::test]
async fn test_tram() {
    let data = std::fs::read_to_string("testdata/departures_1_2479.json").unwrap();
    let ptv = PTV::mock(HashMap::from([("*".to_string(), Ok(data))]));
    let result = ptv
        .departures(&FLINDERS, Default::default())
        .await
        .expect("Parsing failed");
    eprintln!("{:#?}", result);
}

/// Smoke test for parsing real bus data
#[tokio::test]
async fn test_bus() {
    let data = std::fs::read_to_string("testdata/departures_2_17805.json").unwrap();
    let ptv = PTV::mock(HashMap::from([("*".to_string(), Ok(data))]));
    let result = ptv
        .departures(&FLINDERS, Default::default())
        .await
        .expect("Parsing failed");
    eprintln!("{:#?}", result);
}

/// Smoke test for parsing real vline data
#[tokio::test]
async fn test_vline() {
    let data = std::fs::read_to_string("testdata/departures_3_1181.json").unwrap();
    let ptv = PTV::mock(HashMap::from([("*".to_string(), Ok(data))]));
    let result = ptv
        .departures(&FLINDERS, Default::default())
        .await
        .expect("Parsing failed");
    eprintln!("{:#?}", result);
}

#[test]
fn test_parsing_stops() {
    let tests = [
        ("Stop:Train/123", RouteType::TRAIN, 123),
        ("Stop:TRAIN/123", RouteType::TRAIN, 123),
        ("Stop:Tram/0", RouteType::TRAM, 0),
        ("Stop:tram/0", RouteType::TRAM, 0),
        ("Stop:Bus/-1", RouteType::BUS, -1),
        ("Stop:BuS/-1", RouteType::BUS, -1),
        ("Stop:Vline/0999", RouteType::VLINE, 999),
        ("Stop:VLine/0999", RouteType::VLINE, 999),
        ("Stop:NightBus/000", RouteType::NIGHT_BUS, 0),
        ("Stop:NiGhTbUs/000", RouteType::NIGHT_BUS, 0),
    ];
    for (s, route_type, id) in tests {
        let id = StopId::new(id);
        let parsed = Stop::from_str(s).expect(&format!("Failed to parse: {s}"));
        assert_eq!(parsed, Stop { route_type, id }, "Failed to parse: {s}");

        let rt_string = parsed.to_string();
        let rt = Stop::from_str(&rt_string).expect(&format!("Failed to round trip: {s}"));
        assert_eq!(parsed, rt, "Failed to round trip: {s}");
    }
}

#[test]
fn test_parsing_routes() {
    let tests = [
        ("Route:Train/123", RouteType::TRAIN, 123),
        ("Route:TRAIN/123", RouteType::TRAIN, 123),
        ("Route:Tram/0", RouteType::TRAM, 0),
        ("Route:tram/0", RouteType::TRAM, 0),
        ("Route:Bus/-1", RouteType::BUS, -1),
        ("Route:BuS/-1", RouteType::BUS, -1),
        ("Route:Vline/0999", RouteType::VLINE, 999),
        ("Route:VLine/0999", RouteType::VLINE, 999),
        ("Route:NightBus/000", RouteType::NIGHT_BUS, 0),
        ("Route:NiGhTbUs/000", RouteType::NIGHT_BUS, 0),
    ];
    for (s, route_type, id) in tests {
        let id = RouteId::new(id);
        let parsed = Route::from_str(s).expect(&format!("Failed to parse: {s}"));
        assert_eq!(parsed, Route { route_type, id }, "Failed to parse: {s}");

        let rt_string = parsed.to_string();
        let rt = Route::from_str(&rt_string).expect(&format!("Failed to round trip: {s}"));
        assert_eq!(parsed, rt, "Failed to round trip: {s}");
    }
}
